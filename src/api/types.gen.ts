// This file is auto-generated by @hey-api/openapi-ts

export type GitCommitInfo = {
    hash: string;
    shortHash: string;
    date: string;
    tags: Array<(string)>;
};

export type ModuleDependencyProfileCategory = 'hidden' | 'inbound' | 'outbound' | 'transit';

export type Domain = {
    /**
     * Unique node identifier
     */
    id: string;
    /**
     * Node label (name)
     */
    label: string;
    /**
     * ID of the parent node (if it exists)
     */
    parent?: string;
    /**
     * Custom properties of node
     */
    properties: {
        /**
         * How many lowest-layer nodes are contained in this node.
         * 1 if node itself is a leaf.
         * Undefined if it cannot be calculated
         */
        nrLeaves?: number;
        nrRESTProducers?: number;
        nrRESTConsumers?: number;
        nrPublicElements?: number;
        nrEntities?: number;
        nrScreens?: number;
        fileSizeKB?: number;
        /**
         * Cohesion metric of leaves within this node
         */
        cohesion?: number;
        /**
         * Dependency profile of the given node. Quadruple of four categories
         * [hidden, inbound, outbound, transit] if internal (tree) node. Undefined if leaf node.
         */
        dependencyProfile: Array<(number)>;
        /**
         * The type of dependency profile this node is. Only for bottom-layer nodes
         */
        dependencyProfileCategory?: ModuleDependencyProfileCategory;
        /**
         * Whether this node is selected or not
         */
        selected: 'true' | 'false';
        /**
         * Hex color this node should be
         */
        color: string;
        /**
         * Layer this node is in
         */
        layer: string;
        /**
         * Full name of the node (including prefixes)
         */
        fullName: string;
    };
    nrOutgoingDependencies: number;
    nrIncomingDependencies: number;
    nrInternalDependencies: number;
};

export type GraphLayer = {
    label: string;
    classes: Array<(string)>;
    parentLabel?: string;
};

export type ErrorResponse = {
    message: string;
};

export type NodeData = {
    /**
     * Unique node identifier
     */
    id: string;
    /**
     * Node label (name)
     */
    label: string;
    /**
     * ID of the parent node (if it exists)
     */
    parent?: string;
    /**
     * Custom properties of node
     */
    properties: {
        /**
         * How many lowest-layer nodes are contained in this node.
         * 1 if node itself is a leaf.
         * Undefined if it cannot be calculated
         */
        nrLeaves?: number;
        nrRESTProducers?: number;
        nrRESTConsumers?: number;
        nrPublicElements?: number;
        nrEntities?: number;
        nrScreens?: number;
        fileSizeKB?: number;
        /**
         * Cohesion metric of leaves within this node
         */
        cohesion?: number;
        /**
         * Dependency profile of the given node. Quadruple of four categories
         * [hidden, inbound, outbound, transit] if internal (tree) node. Undefined if leaf node.
         */
        dependencyProfile: Array<(number)>;
        /**
         * The type of dependency profile this node is. Only for bottom-layer nodes
         */
        dependencyProfileCategory?: ModuleDependencyProfileCategory;
        /**
         * Whether this node is selected or not
         */
        selected: 'true' | 'false';
        /**
         * Hex color this node should be
         */
        color: string;
        /**
         * Layer this node is in
         */
        layer: string;
        /**
         * Full name of the node (including prefixes)
         */
        fullName: string;
    };
};

export type Node = {
    data: NodeData;
};

export type EdgeViolations = {
    subLayer: boolean;
    dependencyCycle: boolean;
};

export type EdgeReferences = {
    /**
     * Type of reference used within OutSystems
     * (e.g. Action, Entity, Integration, WebBlock, etc.)
     */
    type: string;
    /**
     * Names of the actual references in OutSystems
     */
    names: Array<(string)>;
};

export type DependencyType = 'compile_time' | 'runtime' | 'entity';

export type EdgeDataProperties = {
    /**
     * Whether this edge is some architectural violation
     */
    violations: EdgeViolations & {
    any: boolean;
};
    /**
     * Actual references in OutSystems
     */
    references: Array<EdgeReferences>;
    /**
     * Type of dependency
     */
    dependencyTypes: Array<DependencyType>;
    /**
     * How many module-level dependencies exist within the source and target node
     */
    nrModuleDependencies: number;
    /**
     * How many actual, function-level dependencies exist within the source and target node
     */
    nrFunctionDependencies: number;
    /**
     * How many times the "weak" relationships are called in the
     * database-inserted timeframe. Undefined if no weak relationship
     */
    nrCalls?: number;
};

export type EdgeData = {
    /**
     * Unique edge identifier
     */
    id: string;
    /**
     * Identifier of source node
     */
    source: string;
    /**
     * Identifier of target node
     */
    target: string;
    /**
     * Edge label
     */
    interaction: string;
    /**
     * Custom properties
     */
    properties: EdgeDataProperties;
};

export type Edge = {
    data: EdgeData;
};

/**
 * Graph as labelled property graph (cytoscape.js format)
 */
export type Graph = {
    name: string;
    nodes: Array<Node>;
    edges: Array<Edge>;
};

/**
 * Edge data without graph properties, but which explicit
 * details about source and target nodes
 */
export type ExtendedSimpleEdgeData = {
    /**
     * Unique edge identifier
     */
    id: string;
    /**
     * Identifier of source node
     */
    source: string;
    /**
     * Identifier of target node
     */
    target: string;
    /**
     * Edge label
     */
    interaction: string;
    /**
     * Source node object
     */
    sourceNode: NodeData;
    /**
     * Target node object
     */
    targetNode: NodeData;
};

export type DependencyCycle = {
    node: NodeData;
    path: Array<ExtendedSimpleEdgeData>;
    length: number;
};

export type DependencyCycleRender = {
    node: NodeData;
    path: Array<ExtendedSimpleEdgeData>;
    length: number;
    actualCycles: Array<DependencyCycle>;
    id: string;
};

export type LayerViolation = {
    /**
     * Unique edge identifier
     */
    id: string;
    /**
     * Identifier of source node
     */
    source: string;
    /**
     * Identifier of target node
     */
    target: string;
    /**
     * Edge label
     */
    interaction: string;
    /**
     * Source node object
     */
    sourceNode: NodeData;
    /**
     * Target node object
     */
    targetNode: NodeData;
    actualEdges: Array<ExtendedSimpleEdgeData>;
};

export type Violations = {
    dependencyCycles: Array<DependencyCycleRender>;
    subLayers: Array<LayerViolation>;
};

export type GraphWithViolations = {
    graph: Graph;
    violations: Violations;
};

export type QueryOptions = {
    layerDepth: number;
    dependencyLength: number;
    /**
     * Query relationships that are contained within the selection
     */
    showSelectedInternalRelations?: boolean;
    /**
     * Query relationships that are contained within the selection's domain
     */
    showDomainInternalRelations?: boolean;
    /**
     * Query relationships that are not contained within the selection's domain
     */
    showExternalRelations?: boolean;
    /**
     * Whether to include applications that existing in the unclassified domain. True by default
     */
    includeUnclassifiedApplications?: boolean;
    /**
     * Query outgoing relationships from the starting point
     */
    showOutgoing?: boolean;
    /**
     * Query incoming relationships from the starting point
     */
    showIncoming?: boolean;
    outgoingRangeMin?: number;
    outgoingRangeMax?: number;
    incomingRangeMin?: number;
    incomingRangeMax?: number;
    /**
     * Return relationships that (after lifting) depend on itself
     */
    selfEdges?: boolean;
    showRuntimeDependencies?: boolean;
    showCompileTimeDependencies?: boolean;
    showEntityDependencies?: boolean;
};

export type Breadcrumb = {
    name: string;
    layerLabel: string;
    id?: string;
    options: Array<NodeData>;
};

export type BaseQueryOptions = {
    layerDepth: number;
};

export type $OpenApiTs = {
    '/version': {
        get: {
            res: {
                /**
                 * Ok
                 */
                200: GitCommitInfo;
            };
        };
    };
    '/graph/domains': {
        get: {
            res: {
                /**
                 * Ok
                 */
                200: Array<Domain>;
            };
        };
    };
    '/graph/layers': {
        get: {
            res: {
                /**
                 * Ok
                 */
                200: Array<GraphLayer>;
            };
        };
    };
    '/graph/import': {
        get: {
            res: {
                /**
                 * Ok
                 */
                200: boolean;
            };
        };
    };
    '/graph/import/parse': {
        post: {
            req: {
                formData?: {
                    /**
                     * Files containing the structure of the landscape
                     * (domains, applications, sublayers, and modules).
                     */
                    structureFiles?: Array<((Blob | File))>;
                    /**
                     * Files containing consumers and producers.
                     */
                    dependencyFiles?: Array<((Blob | File))>;
                    /**
                     * Files containing more details about modules.
                     */
                    detailsFiles?: Array<((Blob | File))>;
                    /**
                     * Files containing dynamic data about integrations and service APIs.
                     */
                    integrationFiles?: Array<((Blob | File))>;
                    /**
                     * Whether the "Layer" layer from the OutSystems Architecture
                     * Canvas should be included in the resulting graph
                     */
                    includeModuleLayerLayer?: string;
                    /**
                     * Whether the output graph should be anonymized
                     */
                    anonymize?: string;
                };
            };
            res: {
                /**
                 * Ok
                 */
                200: string;
            };
        };
    };
    '/graph/import/import': {
        post: {
            req: {
                formData: {
                    /**
                     * Set of nodes
                     */
                    nodes: (Blob | File);
                    /**
                     * Set of edges
                     */
                    relationships: (Blob | File);
                };
            };
            res: {
                /**
                 * No content
                 */
                204: void;
            };
        };
    };
    '/graph/nodes': {
        get: {
            req: {
                name?: string;
            };
            res: {
                /**
                 * Ok
                 */
                200: {
                    count: number;
                    records: Array<{
                        data: NodeData;
                    }>;
                };
            };
        };
    };
    '/graph/nodes/{id}': {
        get: {
            req: {
                dependencyLength: number;
                id: string;
                /**
                 * Whether to include applications that existing in the unclassified domain. True by default
                 */
                includeUnclassifiedApplications?: boolean;
                incomingRangeMax?: number;
                incomingRangeMin?: number;
                layerDepth: number;
                outgoingRangeMax?: number;
                outgoingRangeMin?: number;
                /**
                 * Return relationships that (after lifting) depend on itself
                 */
                selfEdges?: boolean;
                showCompileTimeDependencies?: boolean;
                /**
                 * Query relationships that are contained within the selection's domain
                 */
                showDomainInternalRelations?: boolean;
                showEntityDependencies?: boolean;
                /**
                 * Query relationships that are not contained within the selection's domain
                 */
                showExternalRelations?: boolean;
                /**
                 * Query incoming relationships from the starting point
                 */
                showIncoming?: boolean;
                /**
                 * Query outgoing relationships from the starting point
                 */
                showOutgoing?: boolean;
                showRuntimeDependencies?: boolean;
                /**
                 * Query relationships that are contained within the selection
                 */
                showSelectedInternalRelations?: boolean;
            };
            res: {
                /**
                 * Ok
                 */
                200: GraphWithViolations;
            };
        };
    };
    '/graph/nodes/{id}/breadcrumbs': {
        get: {
            req: {
                id: string;
                layerDepth: number;
            };
            res: {
                /**
                 * Ok
                 */
                200: Array<Breadcrumb>;
            };
        };
    };
};